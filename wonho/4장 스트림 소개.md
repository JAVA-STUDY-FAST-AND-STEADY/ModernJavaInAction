# 스트림 소개

- [x] 1. 스트림이란 무엇인가?
- [x] 2. 스트림 시작하기
- [x] 3. 스트림과 컬렉션
- [x] 4. 스트림 연산
- [x] 5. 마치며
- [x] 6. 배우고 느낀점

<br><br>

## 1. 스트림이란 무엇인가?

---

<br>

 **스트림**은 자바 8 API에 새로 추가된 기능으로, **스트림**을 이용하면, 선언형으로 컬렉션 데이터를 처리할 수 있다. 또한 멀티스레드 코드를 구현하지 않아도, **투명**하게 병렬로 처리가 가능하다. 우선 **스트림이** 어떤 것인지, 코드를 통해 이해해보자.

```java
 List<Dish> lowCaloricDishes = new ArrayList<>();
 for (Dish dish : menu) {
    if (dish.getCalories() < 400) {
        lowCaloricDishes.add(dish);
    }
 }
 Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
    public int compare(Dish o1, Dish o2){
        return Integer.compare(o1.getCalories(), o2.getCalories());
    }
 });
 List<String> lowCaloricDishesName = new ArrayList<>();
 for (Dish dish : lowCaloricDishes) {
    lowCaloricDishesName.add(dish.getName());
 }

 // 위와 같은 복잡한 과정을 스트림을 이용해 질의 하듯이 작성할 수 있다.
 List<String> lowCaloricDishesName = 
                        menu.stream()
                            .filter(dish -> dish.getCalories() < 400)
                            .sorted(comparing(Dish::getCalories))
                            .map(Dish::getName)
                            .collect(toList());
```

 위 코드에서 **stream**을 **parallelStream**으로 바꾸면 멀티코어 아키텍처에서 병렬로 실행할 수 있다. **parallelStream**은 7장에서 더 자세하게 다루므로 일단 눈으로만 보고 지나가자. 

 그렇다면 **스트림**의 기능은 소프트웨어공학적으로 어떠한 이득을 주는가?

 - 선언형으로 코드를 구현할 수 있다. 즉 if 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 필요 없이 **동작**의 수행을 지정할 수 있다. 그리하여 변화하는 요구사항에 쉽게 대응이 가능해진다. (**선언형**)

 - filter, sorted, map, collect와 같은 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다. 파이프라인을 연결해도 여전히 가독성과 명확성이 유지된다. (**조립성**)

 - filter, sorted, map, collect와 같은 연산은 **고수준 빌딩 블록**으로 이루어져 있으므로, 특정 스레드 모델에 제한되어있지 않고 자유롭게 어떤 상황에서든 사용할 수 있다. (**병렬화**)

 즉 **스트림**을 이용하면서 데이터 처리 과정을 병렬화하는 과정 중 스레드와 락에 대한 걱정을 전혀 하지 않아도 된다.

<br><br>

## 2. 스트림 시작하기

---

<br>

 정확하게 **스트림**이란 무엇일까? **스트림**은 **데이터 처리 연산**을 지원하도록, **소스**에서 추출된 **연속된 요소**로 정의한다. 각각의 단어의 정의들을 살펴보자.

 - **연속된 요소** : 컬렉션과 마찬가지로, **스트림**은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. 컬렉션은 자료구조이므로, 컬렉션에서는 시간, 공간 복잡성과 관련된 요소들의 접근 연산이 주를 이루게된다. 반면 **스트림**은 filter, sorted, map 처럼 표현 계산식이 주를 이룬다. 즉 컬렉션의 주제는 데이터이고, 스트림의 주제는 계산이다.

 - **소스** : **스트림**은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로 부터, 데이터를 소비한다. 정렬된 컬렉션으로 **스트림**을 생성하면, 정렬이 그대로 유지된다. 즉, 리스트로 **스트림**을 만들면 요소는 리스트의 요소와 같은 순서를 유지한다.

 - **데이터 처리 연산** : **스트림**은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 **데이터베이스**에서 지원하는 질의와 비슷한 연산을 지원한다.

 - **파이프라이닝** : 대부분의 **스트림** 연산은  **스트림** 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록, **스트림**자신을 반환한다. 그 덕분에 **게으름**, **쇼트서킷**같은 최적화도 얻을 수 있다. 

 - **내부 반복** : 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

 이제 스트림을 이용한 예제를 보고, 어떤 과정으로 가는지 분석해보자.

```java
 List<String> threeHighCaloriesDishesName = 
                        menu.stream() // Stream<Dish>
                            .filter(dish -> dish.getCalories() > 300) // Stream<Dish>
                            .sorted(comparing (Dish::getCalories)) // Stream<Dish>
                            .map(Dish::getName) // Stream<String>
                            .collect(toList()); // List<String>
```
 **스트림**을 이용하면서, 기존에 이용하지 않았던 코드와 비교해보자. 어떤 것이 더 편하고, 간결해 보이는가. 프로그래밍을 잘 모르는 사람이라도 스트림을 이용한 것이 더 간결하고 유연함을 알 수 있다. **스트림** 라이브러리에서는 필터링, 추출, 축소 기능을 제공하므로 직접이 기능을 구현할 필요가 없다. 결과적으로 **스트림 API**는 파이프라인을 더 최적화 할 수 있는 유연성을 제공한다.

<br><br>

## 3. 스트림과 컬렉션

---

<br>

 자바의 기존 컬렉션과 새로운 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. 여기서 **연속된**이라는 표현은 순서와 상관없이 아무 값에나 접속하는 것이 아니라, 순차적으로 값에 접근한다는 것을 의미한다.

 컬렉션과 스트림의 차이
 
 - 컬렉션과 스트림은 데이터를 **언제**계산하느냐가 가장 큰 차이이다. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조로, 컬렉션의 모든 요소는 추가하기 전에 계산되어야 한다.
 
 - 스트림은 이론적으로 **요청할 때만 요소를 계산**하는 고정된 자료구조이다. 결과적으로 스트림은 생산자와 소비자 관계를 형성하고, **게으르게 만들어지는 컬렉션**과 같다. 

 - 컬렉션은 **적극적**으로 생성된다. 생산자 중심이라 생각하면 편한데, 생산자는 먼저 물건을 만들자마자 소비자에게 팔지 않는다. 먼저 다 만든 뒤 창고에 쌓고 팔기를 시작한다.

<br>

### 3.1 딱 한 번만 탐색할 수 있다

<br>

 반복자와 마찬가지로 **스트림**또한 딱 한 번만 탐색할 수 있다. 즉 탐색된 스트림의 요소는 소비된다. 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면, 초기 데이터 소스에서 새로운 스트림을 만들어야 한다. 다음의 예시를 보고 이해하자.

```java
 List<String> title = Arrays.asList("Java8", "In", "Action");
 Stream<String> s = title.stream();
 s.forEach(System.out::println); // title의 각 단어 출력
 s.forEach(System.out::println); // Exception 발생 Stream이 이미 소비됨!
```

<br>

### 3.2 외부 반복과 내부 반복

<br>

 컬렉션 인터페이스를 사용하려면, 사용자가 직접 요소를 반복(for(...), Iterator`<T>`)해야 한다. 이를 **외부 반복**이라고 한다. 하지만, **스트림**은 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는 **내부 반복**을 사용한다. 외부 반복과 내부 반복을 코드로 보며 이해해보자.

```java
 // 외부 반복 코드
 List<String> names = new ArrayList<>();
 for (Dish dish : menu) {
    names.add(dish.getName());
 }
 // 내부적으로 숨겨졌던 반복자를 이용한 외부 반복 코드
 List<String> names = new ArrayList<>();
 Iterator<String> iterator = menu.iterator();
 while (iterator.hasNext()) {
    Dish dish = iterator.next();
    names.add(dish.getName());
 }

 // 내부 반복 코드
 List<String> names = menu.stream()
                          .map(Dish::getName)
                          .collect(toList());
``` 

 다음의 예시를 보면 단번에 이해가 갈 것이다.

 마리오 : "방바닥에 장난감이 있니?"
 소피아 : "네, 공이 있어요"
 마리오 : "좋아 상자에 담자, 방바닥에 장난감이 있니?"
 소피아 : "네, 인형이 있어요"
 마리오 : "좋아 상자에 담자, 방바닥에 장난감이 있니?"
 소피아 : "네, 책이 있어요"
 마리오 : "좋아 상자에 담자, 방바닥에 장난감이 있니?"
 소피아 : "아니요, 아무것도 없어요."
 마리오 : "참 잘했어."

 위 대화처럼 우리는 지금까지 자바 컬렉션을 사용해서 구현했다. 즉 **외부적으로** 반복하며, 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다. 소피아에게 장난감을 모두 모아 가져다 상자에 넣으라고 할 수 있다면, 얼마나 좋을까? **내부 반복**이 더 좋은 이유는 소피아에게 한손에는 공, 다른 한손에는 인형을 들게 할 수 있다는 점이고, 모든 장난감을 상자에 가까이 이동시킨 후 담을 수 있다는 장점이 있다. 이렇듯 **내부 반복**을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리가 가능하다. 또한 가장 핵심적인 부분은 **스트림** 라이브러리의 **내부 반복**은 데이터의 표현과 하드웨어를 사용한 병렬성 구현을 자동으로 선택한다. 반면 for-Each를 이용하는 **외부 반복**의 경우 병렬성을 **스스로 관리**해야 한다.

<br><br>

## 4. 스트림 연산

---

<br>

 **스트림 인터페이스**는 많은 연산을 정의한다. 크게 두 가지로 구분이 가능하며, 연결이 가능한 **스트림**을 **중간 연산**이라고 하며, **스트림**을 닫는 연산을 **최종 연산**이라고 한다. 왜 **스트림**은 굳이 연산을 2가지로 구분지으려 하는 것일까? 먼저 **중간 연산**과 **최종 연산**을 알아보며 찾아보자.

```java
 List<String> names = menu.stream()
                          .filter(dish -> dish.getColaries() > 300) // 중간 연산
                          .map(Dish::getName) // 중간 연산
                          .limit(3) // 중간 연산
                          .collect(toList()); // 최종 연산
``` 

<br>

### 4.1 중간 연산

<br>

 filter나 sorted 같은 **중간 연산**은 다른 **스트림**으로 반환한다. 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다. **중간 연산**의 중요한 특징은 단말 연산을 **스트림** 파이프라인에 실행하기 전까지는 아무 연산도 실행하지 않는 것이다. 즉 **게으르다**라는 것이다. **중간 연산**을 합친 다음에 합쳐진 **중간 연산**을 최종 연산으로 처리하기 때문이다. **스트림의 중간 연산**이 어떠한 단계로 이루어지는지 코드를 통해 살펴보자.

```java
 List<String> names = menu.stream()
                          .filter(dish -> {
                            System.out.println("filtering : " + dish.getName());
                            return dish.getColaries() > 300;}) // 중간 연산
                          .map(dish -> {
                            System.out.println("mapping : " + dish.getName());
                            return dish.getName();
                          }) // 중간 연산
                          .limit(3) // 중간 연산
                          .collect(toList()); // 최종 연산
 //실행 결과
 // filtering : pork
 // mapping : pork
 // filtering : beef
 // mapping : beef
 // filtering : chicken
 // mapping : chicken
```

 **스트림**의 게으른 특성 덕분에 몇가지 최적화 효과를 얻을 수 있었다. 첫째, 300칼로리가 넘는 음식은 여러개 지만, limit(3)로 3개만 선택 되었다. 이는 limit 연산, **쇼트 서킷**이라 불리는 기법 덕분이다. 둘째, filter와 map은 서로 다른 연산이지만, 한 과정으로 병합 되었다. 이것을 **루프 퓨전**이라고 한다.

<br>

### 4.2 최종 연산

<br>

 **최종 연산**은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 List, Integer, void 등 **스트림** 이외의 결과가 반환된다.

<br>

### 4.3 스트림 이용하기

<br>

 **스트림**의 이용 과정은 다음과 같이 세 가지로 요약할 수 있다.

 - 질의를 수행할 (컬렉션 같은) 데이터 소스

 - 스트림 파이프라인을 구성할 중간 연산 연결

 - 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

 **스트림 파이프라인**의 개념은 **빌더 패턴**과 비슷하다. **빌더 패턴**에서는 호출을 연결해서, 설정을 만든다.(스트림의 중간 연산을 연결하는 것과 같다.) 그리고 준비된 설정에 build 메서드를 호출한다. 

 다음은 스트림이 제공하는 **중간 연산**과 **최종 연산**의 일부 연산들이다.

 **중간 연산**

 | 연산 | 형식 | 반환 형식 | 연산의 인수 | 함수 디스크립터 |
 |-----|-----|---------|----------|-------------|
 |filter|중간 연산 | Stream`<T>`| Predicate`<T>`| T -> boolean |
 |map|중간 연산 | Stream`<T>`| Function`<T, R>` | T -> R |
 |sorted| 중간 연산 | Stream`<T>`| Comparator`<T>`| (T, T) -> int |
 |limit| 중간 연산 | Stream`<T>`|
 |distinct| 중간 연산 | Stream`<T>`|
 **최종 연산**

 | 연산 | 형식 | 반환 형식 | 목적 |
 |-----|-----|--------|-----|
 |forEach| 최종 연산 | void | 스트림의 각 요소를 소비하면서 람다를 적용한다.|
 |count| 최종 연산 | long | 스트림의 요소 개수를 반환한다.|
 |collect| 최종 연산 | | 스트림을 리듀스해서, 리스트, 맵, 정수 형식의 컬렉션을 만든다.|


<br><br>

## 5. 마치며

---

<br>

 - **스트림**은 소스에서 추출된 연속 요소로 데이터 처리 연산을 한다.

 - **스트림**은 내부 반복을 지원한다. 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화한다.

 - **스트림**에는 중간 연산과 최종 연산이 있다.

 - **중간 연산**은 filter, map 처럼 스트림을 반환하면서, 다른 연산과 연결되는 연산이다. 중간 연산을 이용해서 파이프라인을 구성할 수 있지만, 중간 연산으로는 어떤 결과도 생성할 수 없다.

 - **forEach나 count**처럼 스트림 파이프라인을 처리해서, 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고 한다.

 - **스트림**의 요소는 요청할 때 **게으르게** 계산된다.

<br><br>

## 6. 배우고 느낀점

---

<br>

 이전까지는 스트림을 이용만 했을 뿐이라면, 좀 더 자세하고 고급화 하기위해 읽고 있는 중이다. 그에 대해 4장은 간단한 스트림 사용법과 구성 등 내가 알고싶어하는 부분을 쪼개서 잘 알려주고있다. 5장 6장 7장을 읽고나서 나의 스트림에 대한 이해가 더 깊어질걸 생각하며, 열심히 읽어야겠다.