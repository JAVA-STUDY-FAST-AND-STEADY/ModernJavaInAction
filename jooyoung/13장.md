--- 
- 전통적인 자바에서 인터페이스와 관련 메서드는 한 몸처럼 구성된다.
- 인터페이스를 구현하는 클래스는 인터페이스에서 정의하는 모든 메서드 구현을 제공하거나 아니면 슈퍼클래스의 구현을 상속받아야 한다
- 인터페이스에 새로운 메서드를 추가하는 등 인터페이슬 바꾸고 싶을 때는 이러한 규칙이 문제가 될 수 있다
	- 인터페이스를 바꾸면 이전에 해당 인터페이스를 구현했던 모든 클래스의 구현도 고쳐야 하기 때문이다
	- 자바8API에도 List 인터페이스에 sort같은 메서드를 추가했으므로 문제가 발생할 수 있다
	- 기존의 List인터페이스를 구현했던 모든 프로그램이 sort메서드를 구현하도록 List인터페이스를 상속한 모든 클래스를 고쳐야 한다면 매우 당황스러울 것이다
- 이러한 문제를 해결하기 위해 자바8에서는 인터페이스를 정의하는 두 가지 방법을 제공한다
	- 정적 메서드 사용
	- 디폴트 메서드 사용
	- 즉 자바 8은 메서드 구현을 포함하는 인터페이스를 정의할 수 있다
	- 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다
```java
default void sort(Comparator<? super E> c){
	Collections.sort(this, c);
}
```
- default 키워드는 해당 메서드가 디폴트 메서드임을 가리킨다
- 디폴트 메서드는 주로 라이브러리 설계자들이 사용한다

--- 
#### 변화하는 API
```java
public interface Resizable extends Drawable {  
  
  int getWidth();  
  int getHeight();  
  void setWidth(int width);  
  void setHeight(int height);  
  void setAbsoluteSize(int width, int height);  
}
```
- 기존 Resizable 인터페이스
```java
public class Ellipse implements Resizable{}
```
- 기존 Resizable 인터페이스를 구현한 Ellipse 클래스
	- Ellipse클래스는 라이브러리 설계자가 아닌 사용자가 집접 구현한 클래스
```java
public class Game {  
  
  public static void main(String... args) {  
    List<Resizable> resizableShapes = Arrays.asList(  
        new Square(), new Triangle(), new Ellipse());  
    Utils.paint(resizableShapes);  
  }  
  
}
  public static void paint(List<Resizable> l) {  
    l.forEach(r -> {  
      r.setAbsoluteSize(42, 42);  
    });  
  }  
  
}
```
- 이 사용자는 다양한 Resizable 모양(자신이 만든 Ellipse포함)을 처리하는 게임을 만들었다

- 여기서 Resizable 인터페이스에 setRelativeSize(int, int) 메서드를 추가한다면?
	- Ellipse같은 Resizable 인터페이스를 구현한 모든 클래스에서 setRelativeSIze 메서드를 구현해야한다
	- Ellipse는 라이브러리 사용자가 직접 구현한 클래스이므로 setRelativeSize 를 구현하지 않는다
- 인터페이스에 새로운 메서드를 추가하면 ***바이너리 호환성*** 은 유지된다
	- 바이너리 호환성이란 새로 추가된 메서드를 호출하지만 않으면 새로운 메서드 구현이 없이도 기존 클래스 파일 구현이 잘 동작한다는 의미다
	- 하지만 언젠가는 누군가가 Resizable 을 인수로 받는 Utils.paint에서 setRelativeSize 를 사용하도록 코드를 바꿀 수 있다
	- 이때 Ellipse 객체가 인수로 전달되면 Ellipse는 setRelativeSize 메서드를 정의하지 않았으므로 런타임에 에러가 발생한다
	- 또 사용자가 Ellipse를 포함하는 전체 애플리케이션을 재빌드할 때도 에러가 발생한다
- 바이너리 호환성, 소스 호환성, 동작 호환성
	- 바이너리 호환성 : 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황
		- 인터페이스에 새로운 메서드를 추가했을 때 추가된 메서드를 호출하지 않는 한 문제가 일어나지 않는것
	- 소스 호환성 : 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일 할 수 있음을 의미
		- 인터페이스에 새로운 메서드를 추가하면 소스호환성이 아님(재컴파일 불가)
	- 동작 호환성 : 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미
		- 인터페이스에 메서드를 추가하더라도 프로그램에서 추가된 메서드를 호출할 일은 없으므로 동작 호환성은 유지된다
 --- 
#### 디폴트 메서드란 무엇인가?
- 호호나성을 유지하면서 API를 바꿀 수 있도록 자바8에서 디폴트 메서드를 추가
- 인터페이스를 구현하는 클래스에서 구현하지 않은 메서드는 인터페이스 자체이서 기본으로 제공
	- 그래서 이를 디폴트 메서드라고 부름
- 디폴트 메서드는 default라는 키워드로 시작하며 다른 클래스에 선언된 메서드처럼 메서드 바디를 포함
- 인터페이스가 구현을 가질 수 있고 클래스는 여러 인터페이스를 동시에 구현할 수 있으므로 결국 자바도 다중 상속을 지원하는 걸까?
	- 인터페이스를 구현하는 클래스가 디폴트 메서드와 같은 메서드 시그니처를 정의하거나 아니면 디폴트 메서드를 오버라이드한다면 어떻게 될까?

- 추상 클래스와 인터페이스 차이
	- 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 여러개 구현할 수 있따
	- 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없다

--- 
#### 디폴트 메서드 활용 패턴
- 선택형 메서드
	- 인터페이스를 구현하는 클래스에서 메서드의 내용이 비어있는 상황이 있다
		- 이는 사용자들이 잘 사용하지 않는 기능으로, 기존 자바에서는 구현 클래스에서 추상 메서드로 남길 수 없기 때문에 내용이 비어있는 메서드를 구현했다
		- 하지만 디폴트 메서드가 생기면서 인터페이스에서 기본 구현을 제공할 수 있으므로 이런 불필요한 코드를 줄일 수 있다
- 동작 다중 상속
	- 디폴트 메서드를 이용하면 기존에는 불가능했던 동작 다중 상속 기능도 구현할 수 있다
	- 상속은 한개만 가능하지만 구현은 여러개가 가능하기 떄문
```java
public class ArrayList<E> extends AbstractList<E>  
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
        {...}
```
- 이 처럼 ArrayList는 여러 인터페이스를 구현하고, 이 인터페이스들에 디폴트 메서드가 존재하면 여러 인터페이스에서 동작을 상속받을 수 있다
- 인터페이스 조합
	- 이런 특성을 이용해 필요한 인터페이스만 선택해서 구현할 수 있다

--- 
#### 해석 규칙
- 자바8에는 디폴트 메서드가 추가되었으므로 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생길 수 있다
- 이런 상황에서는 어떤 인터페이스의 디폴트 메서드를 사용하게 될까?

- 알아야할 세 가지 해결 규칙
	- 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다
	- 1번 규칙 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브 인터페이스가 이긴다. 즉 B가 A를 상속받는다면 B가 A를 이긴다
	- 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시작으로 디폴트 메서드를 오버라이드하고 호출해야한다

- 충돌 그리고 명시적인 문제 해결
	- 클래스와 메서드 관계로 디폴트 메서드를 선택할 수 없는 상황에서는 선택할 수 있는 방법이 없다
	- 이떄 해당 메서드를 오버라이드 한 다음에 호출하려는 메서드를 명시적으로 선택해야한다
	- 자바 8에서는 X.super.m()형 태의 새로운 문법을 제공한다
		- 여기서 X는 호출하려는 메서드 m의 슈퍼인터페이스다

- 다이아몬드 문제
```java
public interface A{
	default void hello(){
		System.out.println("Hello from A");
	}
}
public interface B extends A{}
public interface C extends A{}
public class D implements B, C{
	public static void main(String... args){
		new D().hello();
	}
}
```
- 이 문제의 다이어그램의 모양이 다이아몬드를 닮았으므로 이를 다이아몬드 문제라고 부른다
- 이떄 실제로 선택할 수 있는 메서드 선언은 하나뿐이다
	- A만 디폴트 메서드를 정의하고 있으므로 Hello from A가 출력된다
- 이때 B에도 같은 시그니처의 디폴트 메서드 hello가 있다면 어 2번 규칙(디폴트 메서드를 제공하는 가장 하위의 인터페이스가 선택)에 의해 가장 하위의 인터페이스가 선택된다
	- B가 A를 상속받으므로 B가 선택된다
- B와 C가 모두 디폴트 메서드 hello 메서드를 정의한다면 충돌이 발생하므로 하나의 메서드를 명시적으로 호출해야한다
- 만약 인터페이스 C에 추상 메서드 hello를 추가하면 C에서는 A에서 상속받은 디폴트 메서드보다 자신이 정의한 추상 메서드가 우선권을 갖는다
- 따라서 컴파일 에러가 발생하며, 클래스 D가 어떤 hello를 사용할지 명시적으로 선택해서 에러를 해결해야한다


