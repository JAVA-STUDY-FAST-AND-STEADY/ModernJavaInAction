--- 
- 자바9에서 가장 많이 거론되는 새로운 기능은 바로 모듈 시스템이다
- 모듈 시스템은 직소 프로젝트 내부에서 개발된 기능으로 완성까지 거의 십년이 걸렸다
- 이처럼 모듈 시스템을 중요하다

--- 
#### 압력 : 소프트웨어 유추
- 자바 모듈 시스템을 자세히 살펴보기 전에 어떤 동기와 배경으로 자바 언어 설계자들이 목표를 정했는지 이해해보자

- 관심사 분리(SoC)
	- 관심사 분리는 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다
	- 서로 거의 겹치지 않는 코드 그룹으로 분리하는 것
	- 다시말해 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다
- 자바9 모듈은 클래스가 어떤 다른 클래스를 볼 수 있는지를 컴파일 시간에 정료하게 제어할 수 있다
- SoC원칙의 장점
	- 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다
	- 개별 부분을 재사용하기 쉽다
	- 전체 시스템을 쉽게 유지보수할 수 있다
- 정보 은닉
	- 정보 은닉은 세부 구현을 숨기도록 장려하는 원칙이다
	- 소프트웨어를 개발할 때 요구사항은 자주 바뀐다
	- 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다
	- 즉, 코드를 관리하고 보호하는 데 유용한 원칙이다
	- 자바9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 수있는 기능이 없었다

--- 
#### 자바 모듈 시스템을 설계한 이유
- 모듈화의 한계
	- 자바9 이전까지는 모듈화된 소프트웨어 프로젝트를 만드는 데 한계가 있었다
	- 자바는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화를 제공한다
	- 하지만 패키지와 JAR수준에서는 캡슐화를 거의 지원하지 않았다
- 제한된 가시성 제어
	- 자바는 정보를 감출 수 있는 접근자를 제공한다(public, protected, 패키지 수준, private)
	- 많은 애플리케이션은 다양한 클래스 그룹을 정의한 여러 패키지가 있는데 패키지의 가시성 제어 기능은 유명무실한 수준이다
	- 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public으로 이들을 선언해야 한다
	- 결과적으로 이들 클래스와 인터페이스는 모두에게 공개된다
- 클래스 경로
	- 자바는 클래스를 모두 컴파일한 다음 보통 한개의 평범한 JAR파일에 넣고 클래스 경로에 이 JAR파일을 추가해 사용할 수 있다
	- 안타깝게도 클래스 경로와 JAR 조합에는 몇 가지 약점이 존재한다
		- 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다
	- 클래스 경로는 명시적인 의존성을 지원하지 않는다
		- 각각의 JAR안에 있는 모든 클래스는 classes라는 한 주머니로 합쳐진다
		- 즉 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않는다

- 거대한 JDK
	- 자바 개발 키트는 자바 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합이다
	- JDK가 거대해지면서 애플리케이션에 사용하는지와 관계 없이 모든 클래스가 포함되었다
	- 자바8에서는 컴팩트 프로파일이라는 기법을 제시했다
		- 관련 분야게 따라 JDK 라이브러리가 세 가지 프로파일로 나뉘어 각각 다른 메모리 풋프린트를 제공했다
	- JDK라이브러리의 많은 내부 API는 공개되지 않아야 한다
	- 안타깝게도 자바 언어의 낮은 캡슐화 지원 때문에 내부 API가 외부에 공개되었다
	- 이런 문제들 때문에 JDK 자체도 모듈화할 수 있는 자바 모듈 시스템 설계의 필요성이 제기 되었다

--- 
#### 자바 모듈 : 큰 그림
- 자바8은 모듈이라는 새로운 자바 프로그램 구조 단위를 제공한다
- 모듈은 module이라는 새 키워드에 이름과 바디를 추가해서 정의한다
- 모듈 디스크립터는 module-info.java라는 특별한 파일에 저장된다
- 모듈 디스크립터는 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다

--- 
#### 자바 모듈 시스템으로 애플리케이션 개발하기
- 시스템을 모듈화할 때 모듈 크기를 결정해야 한다
- 세부적인 모듈화 기법 대부분은 모든 패키지가 자신의 모듈을 갖는다
- 거친 모듈화 기법 대부분은 한 모듈이 시스템의 모든 패키지를 포함한다
- 첫번째 기법은 이득에 비해 설계 비용이 증가하는 반면 두 번째 기법은 모듈화의 모든 장점을 잃는다
- 가장 좋은 방법은 시스템을 실용적으로 분해하면서 진화하는 소프트웨어 프로젝트가 이해하기 쉽고 고치기 쉬운 수준으로 적절하게 모듈화 되어 있는지 주기적으로 확인하는 프로세스를 갖는것이다
- module-info.java 라는 파일은 모듈 디스크립터로 모듈의 소스 코드 파일 루트에 위치해야 하며 모듈의 의존성 그리고 어떤 기능을 외부로 노출할지를 정의한다
- exports구문
	- exports는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다
	- 기본적으로 모듈 내의 모든 것은 캡슐화된다
	- 모듈 시스템은 화이트 리스트 기법을 이용해 강력한 캡슐화를 제공하므로 다른 모듈에서 사용할 수 있는 기능이 무엇인지 명시적으로 결정해야 한다
- requires구분
	- requires는 의존하고 있는 모듈을 지정한다
	- 기본적으로 모든 모듈은 java.base라는 플랫폼 모듈에 의존하는데 이 플랫폼 모듈은 net, io, util 등의 자바 메인 패키지를 포함한다
- requires transitive
	- 다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정할 수 있다
- exports to
	- exports to 구문을 이용해 사용자에게 공개할 기능을 제한함으로 가시성을 좀 더 정교하게 제어할 수 있다
- open과 opens
	- 모듈 선언에 open한정자를 이용하면 모든 패키지를 다른 모듈에 반사적으로 접근을 허용할 수 있다
- 오라클은 패키지명처럼 인터넷 도메인명을 역순으로 모듈의 이름을 정하도록 권고한다
- 더욱이 모듈명은 노출된 주요 API 패키지와 이름이 같아야 한다는 규칙도 따라야 한다
- 모듈이 패키지를 포함하지 않거나 어떤 다른 이유로 노출된 패키지 중 하나와 이름이 일치하지 않는 상황을 제외하면 모듈명은 작성자의 인터넷 도메인명을 역순으로 시작해야 한다