--- 
### 동시성을 구현하는 자바 지원의 진화
- 처음에 자는 Runnable과 Thread를 동기화된 클래스와 메서드를 이용해 잠갔다
	- 자바5는 좀 더 표현력 있는 동시성을 지원하는 특히 스레드 실행과 태스크 제출을 분리하는 ExecutorService 인터페이스 즉, Runnable, Thread의 변형을 반환하는 Callable\<T\> and Future\<T\> , 제네릭 등을 지원했다
- 자바는 Future를 조합하는 기능을 추가하면서 동시성을 강화했고, 자바9에서는 분산 비동기 프로그래밍을 명시적으로 지원한다.
- CompletableFuture와 java.util.concurrent.Flow의 궁극적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면ㄷ서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다

### 스레드와 높은 수준의 추상화
- 운영체제는 두 사용자가 각각 자신만의 공간에 있다고 생각할 수 있도록 가상 주소 공간을 각각의 프로세스에 제공한다
- 운영체제는 주기적으로 번갈아가며 각 프로세스에 CPU를 할당함으로 실제로 마술 같은 일이 일어난다
- 프로세스는 다시 운영체제에 한 개 이상의 스레드 즉, 본인이 가진  프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로 태스크를 동시에 또는 협력적으로 실행할 수 있다
- 스트림은 외부 반복(명시적 루프)보다 높은 수준의 개념이다
- 스트림을 이용해 스레드 사용 패턴을 추상화할 수 있다

### Executor와 스레드 풀
- 자바5는 Executor 프레임워크와 스데르 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 자바 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공했다
- 스레드의 문제
	- 자바 스레드는 직접 운영체제 스레드에 접근한다
	- 운영체제 스레들르 만들고 종료하려면 비싼 비용을 치러야하며 더욱이 운영체제 스레드의 숫자는 제한되어 있다는 것이 문제다
	- 운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방식으로 크래시될 수 있으므로 기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다
	- 다양한 기기에서 실행할 수 있는 프로그램에서는 미리 하드웨어 스레드 개수를 추측하지 않는것이 좋다
- 스레드 풀 그리고 스레드 풀이 더 좋은 이유
	- 자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다
	- 프로그램은 newFixedThreadPool 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다
	```java
ExecutorService newFixedThreadPool(int nThreads)
	```
	- 이 메서드는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorServicefㅡㄹ 만들고 이들을 스레드 풀에 저장한다
	- 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행한다
	- 이들 태스크 실행이 종료되면 이들 스레드를 풀로 반환한다
	- 이 방식의 장점은 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다
	- 프로그라머가 태스크(Runnable, Callable) 을 제공하면 스레드가 이를 실행한다
- 스레드 풀 그리고 스레드 풀이 나쁜 이유
	- 스레드 풀을 이용할때는 다음 두가지 사항을 주의해야 한다
	1. k 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전에 태스크 중 하나가 종료되기 전까지는 스레드에 할당하지 않는다. 불필요하게 많은 스레드를 만드는 일을 피할 수 있으므로 보통 이 상황은 아무 문제가 되지 않지만 잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다. I/O를 기다리는 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만 아무 작업도 하지 않게 된다. 네 개의 하드웨어 스레드와 5개의 스레드를 갖는 스레드 풀에 20개의 태스크를 제출했다고 가정하자. 모든 태스크가 병렬로 실행되면서 20개의 태스크를 실행할 것이라 예상할 수 있다. 하지만 처음 제출한 세 스레드가 잠을 자거나 I/O를 기다린다고 가정하자. 그러면 나머지 15개의 태스크를 두 스레드가 실행해야 하므로 작업 효율성이 예상보다 절반으로 떨어진다). 처음 제출한 태스크가 기존 실행 중인 태스크가 나중의 내스크 제출을 기다리는 상황(Future의 일반적인 패턴)이라면 데드락에 걸릴 수도 있다. 핵심은 블록(자거나 이벤트를 기다리는)할 수 있는 태스크는 스레드 풀에 제출하지 말아야 한다는 것이지만 항상 이를 지킬 수 있는 것은 아니다.
	2. 중요한 코드를 실행하는 스레드가 죽는 일이 발생하지 않도록 보통 자바 프로그램은 main이 반환하기 전에 모든 스레드의 작업이 끝나길 기다린다. 따라서 프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다(풀의 워커 스레드가 만들어진 다음 다른 태스크 제출을 기다리면서 종료되지 않은 상태일 수 있으므로). 보통 장기간 실행하는 인터넷 서비스를 관리하도록 오래 실행되는 ExecutorService를 갖는 것은 흔한 일이다. 자바는 이런 상황을 다룰 수 있도록 15.1.3절에서 설명하는 Thread.setDaemon 메서드를 제공한다.
- 스레드에 무엇을 바라는가?
	- 일반적으로 모든 하드웨어 스레드를 활용해 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉, 프로그램을 작은 태스크 단위로 구조화하는 것이 목표다

--- 
### 동기 API와 비동기 API
```java
int f(int x)
int g(int x)
```
- 위와 같은 시그니처를 갖는 f, g 두 메서드의 호출을 합하는 예제를 살펴보자
- 이들 메서드는 물리적 결과를 반환하므로 동기 API라고 부른다
```java
class ThreadExample {    
	public static void main(String[] args) throws InterruptedException {        
		int x = 1337;        
		Result result = new Result();        
		Thread t1 = new Thread(() -> { result.left = f(x); } );        
		Thread t2 = new Thread(() -> { result.right = g(x); });        
		t1.start();        
		t2.start();       
		t1.join();       
		t2.join();     
		System.out.println(result.left + result.right);    
		}    
	private static class Result {        
		private int left;        
		private int right;    
	}
}

```
- 코드가 난잡해졌다
```java
public class ExecutorServiceExample {  
  
  public static void main(String[] args) throws ExecutionException, InterruptedException {  
    int x = 1337;  
  
    ExecutorService executorService = Executors.newFixedThreadPool(2);  
    Future<Integer> y = executorService.submit(() -> fo(x));  
    Future<Integer> z = executorService.submit(() -> go(x));  
    System.out.println(y.get() + z.get());  
  
    executorService.shutdown();  
  }  
  
}
```
- Runnable대신 Future API 인터페이스를 이용해 코드를 단순화 했다
- 하지만 여전히 명시적인 submit메서드 호출 같은 불필요한 코드로 오염되었다
- 문제의 해결은 비동기 API라는 기능으로 API를 바꿔서 해결할 수 있다
#### Future형식 API
- 대안을 이용하면 f,g의 시그니처가 다음처럼 바뀐다
```java
Future<Integer> f(int x);
Future<Integer> g(int x);
```
- 그리도 다음처럼 호출이 바뀐다
```java
Future<Integer> y = f(x);
Future<Integer> z = g(x);
System.out.println(y.get() + z.get());
```
- 메서드 f는 호출 즉시 자신의 원래 바디를 평가하는 태스크를 포함하는 Future를 반환한다. 마찬가지로 메스드 g도 Future를 반환하며 세 번째 코드는 get() 메서드를 이용해 두 Future가 완료되어 결과가 합쳐지기를 기다린다.

### 리엑티브 형식 API
- 두 번쨰 대안에서 핵심은 f,g의 시그니처를 바꿔서 콜백 형식의 프로그래밍을 이용하는 것이다
```java
void f(int x, IntConsumer dealWithResult);
```
- f에 추가 인수로 콜백(람다)7을 전달해서 f의 바디에서는 return 문으로 결과를 반환하는 것이 아니라 결과가 준비되면 이를 람다로 호출하는 태스크를 만든다.
- 다시 말해 f는 바디를 실행하면서 태스크를 만든 다음 즉시 반환하므로 코드 형식이 다음처럼 바뀐다.
```java
public static void main(String[] args) {  
  
  int x = 1337;  
  Result result = new Result();  
  
  f(x, (int y) -> {  
    result.left = y;  
    System.out.println((result.left + result.right));  
  });  
  
  g(x, (int z) -> {  
    result.right = z;  
    System.out.println((result.left + result.right));  
  });  
}
```
- 하지만 결과가 달라졌다. f와 g의 호출 합계를 정확하게 출력하지 않고 상황에 따라 먼저 계산된 결과를 출력한다. 락을 사용하지 않으므로 값을 두 번 출력할 수 있을 뿐더러 때로는 +에 제공된 두 피연산자가 println이 호출되기 전에 업데이트될 수도 있다. 다음처럼 두 가지 방법으로 이 문제를 보완할 수 있다
	- if-then-else를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 println을 호출해 원하는 기능을 수행할 수 있다.
	- 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 Future를 이용하는 것이 더 적절하다.
- 리액티브 형식의 프로그래밍으로 메서드 f와 g는 dealWithResult 콜백을 여러 번 호출할 수 있다. 원래의 f, g 함수는 오직 한 번만 return을 사용하도록 되어있다. 
- 마찬가지로 Future도 한 번만 완료되며 그 결과는 get()으로 얻을 수 있다. 
- 리액티브 형식의 비동기 API는 자연스럽게 일련의 값(나중에 스트림으로 연결)을,  Future 형식의 API는 일회성의 값을 처리하는 데 적합하다.

#### 잠자기(그래고 기타 블로킹 동작)는 해로운 것으로 간주
- 사람과 상호작용하거나 어떤 일이 일정 속도로 제한되어 일어나는 상황의 애플리케이션을 만들 때 자연스럽게 sleep() 메서드를 사용할 수 있다. 하지만 스레드는 잠들어도 여전히 시스템 자원을 점유한다. 스레드를 단지 몇 개 사용하는 상황에서는 큰 문제가 아니지만 스레드가 많아지고 그 중 대부분이 잠을 잔다면 문제가 심각해진다
- 스레드 풀에서 잠자는 스레드만 실행을 막는것은 아니다. 모든 블록 동작도 마찬가지다. 블록 동작은 다른 태스크가 어떤 동작을 완료하기를 기다리는 동작(예를 들어, Future에 get() 호출)과 외부 상호작용(예를 들어, 네트워크, 데이터베이스 서버에서 읽기 작업을 기다리거나, 키보드 입력 같은 사람의 상호작용을 기다림)을 기다리는 동작 두 가지로 구분할 수 있다.
- 이상적으로는 절대 태스크에서 기다리는 일을 만들지 말거나 아니면 코드에서 예외를 일으키는 방법으로 이를 처리할 수 있다

#### 현실성 확인
- 새로운 시스템을 설계할 때 시스템을 많은 작은 동시 실행되는 태스크로 설계해서 블록할 수 있는 모든 동작을 비동기 호출로 구현한다면 병렬 하드웨어를 최대한 활용할 수 있다.
- 현실적으로는 모든 것은 비동기라는 설계 원칙을 어겨야 한다(최상은 좋은 것의 적이다라는 속담을 기억하자)

#### 비동기 API에서 예외는 어떻게 처리하는가?
- Future나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의 실행 범위와는 관계가 없는 상황이 된다. 예상치못한 일이 일어나면 예외를 발생시켜 다른 동작이 실행되어야 한다. 어떻게 이를 실현할 수 있을까?
	- Future나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의 실행 범위와는 관계가 없는 상황이 된다. 예상치못한 일이 일어나면 예외를 발생시켜 다른 동작이 실행되어야 한다. 어떻게 이를 실현할 수 있을까?
- 리액티브 형식의 비동기 API에서는 return 대신 기존 콜백이 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야 한다. 다음 예제처럼 리액티브 API에 여러 콜백을 포함해야 한다.
- 콜백이 여러 개면 이를 따로 제공하는 것보다는 한 객체로 이 메서드를 감싸는 것이 좋다. 예를 들어 자바 9 플로 API에서는 여러 콜백을 한 객체(네 개의 콜백을 각각 대표하는 네 메서드를 포함하는 Subscriber\<T\> 클래스)로 감싼다
```java
void onComplete()
void OnError(Throwable throwable)
void onNext(T item);
```
- 값이 있을 때(onNext), 도중에 에러가 발생했을 때(onError), 값을 다 소진했거나 에러가 발생해서 더 이상 처리할 데이터가 없을 때(onComplete) 각각의 콜백이 호출된다
- 보통 이런 종류의 호출을 메시지 또는 이벤트라 부른다.
- 이런 이벤트를 API의 일부로 보자면 API는 이벤트의 순서(채널 프로토콜이라 불리는)에는 전혀 개의치 않는다.

--- 
### CompletableFuture와 콤비네이터를 이용한 동시성
- 동시 코딩 작업을 Future 인터페이스로 생각하도록 유도한다는 점이 Future 인터페이스의 문제다
- 하지만 역사적으로 주어진 연산으로 Future를 만들고, 이를 실행하고, 종료되길 기다리는 등 Future는 FutureTask 구현을 뛰어 넘는 몇 가지 동작을 제공했다. 이후 버전의 자바에서는 7장에서 설명한 RecursiveTask 같은 더 구조화된 지원을 제공했다.
- 자바 8에서는 Future 인터페이스의 구현인 CompletableFuture를 이용해 Future를 조합할 수 있는 기능을 추가했다
- 일반적으로 Future는 실행해서 get()으로 결과를 얻을 수 있는 Callable로 만들어진다. 하지만 CompletableFuture는 실행할 코드 없이 Future를 만들 수 있도록 허용하며 complete() 메서드를 이용해 나중에 어떤 값을 이용해 다른 스레드가 이를 완료할 수 있고 get()으로 값을 얻을 수 있도록 허용한다(그래서 CompletableFuture라 부른다)

--- 
### 발행-구독 그리고 리액티브 프로그래밍
- Future와 CompletableFuture은 독립적 실행과 병렬성이라는 정식적 모델에 기반한다. 연산이 끝나면 get()으로 Future의 결과를 얻을 수 있다. 따라서 Future는 한 번만 실행해 결과를 제공한다.
- 반면 리액티브 프로그래밍은 시간이 흐르면서 여러 Future 같은 객체를 통해 여러 결과를 제공한다.

