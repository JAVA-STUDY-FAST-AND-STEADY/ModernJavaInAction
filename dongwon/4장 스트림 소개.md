# 스트림 소개

스트림을 설명하기에 앞서 자바는 프로그래밍 작업하는데 연산을 해 작업을 한다. 이러한 작업과 반대되는 SQL 질의 언어가 있는데 이 같은 경우 선언형으로, 기대하는 것이 무엇이든 **직접 표현**할수 있다, 어떻게 표현해야 할지 명시할 필요없고 구현은 자동으로 된다. 

이와 같은 동작을 컬렉션으로 만들기 위해서 스트림이 나오게 되었다

**스트림**은 선언형(데이터를 처리하는 임시 구현 코드 대신 질의로 표현하는것)으로 컬렉션 데이터를 처리할 수 있다 간단하게 생각하면 ‘스트림은 데이터 컬렉션 반복을 처리하는 기능’ 으로 멀티스테드 코드 구현 없이 데이터 **투명하게** 병렬 처리 가능하다 

<br>

filter, sorted, map, collect 와 같은 **고수준 빌딩 블록**으로 이루어져 특정 스레딩 모델에 제한 없이 자유롭게 사용할 수 있다 ( 내부적론 단일 스레드 모델에 사용할 수 있지만 멀티코어 아키텍처 최대한 투명하게 활용할 수 있게 구현되어 있다)

⇒ 결론적으로 데이터 처리 과정을 병렬화 하면서 스레드와 락을 걱정할 필요가 없어짐

```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));

Map 의 결과
{
		FISH=[prawns, salmon],
		OTHER=[french fries, rice, season fruit, pizza],
		MEAT=[pork, beef, chicken]
}
```

<br>

자바8 스트림 API의 특징

- 선언형 : 더 간결하고 가독성 좋아짐
- 조립 가능 : 유연성 좋아짐
- 병렬화 : 성능 좋아짐

**스트림은 ‘데이터 처리 연산을 지원하도록 추출된 연속으로 구성된 요소’ 라 볼수 있다**

- 연속된 요소 : 특정 요소 형식 이루어진 연속된 집합값 인터페이스 제공
    
    Collection 
    
    ArrayList 사용과 LinkedList 사용할것인가. 시간과 공간의 복잡성과 관련된 요소 저장과 접근 연산이 주를 이룸
    
    Stream
    
    filter, sorted, map 과 같은 표현 계산식이 주를 이룸
    

- 소스 : 데이터 제공 소스로부터 데이터를 소비, 정렬된 컬렉션으로 스트림 생성시 정렬 그대로 유지 → 리스트로 스트림 만들시 순서 유지됨!

- 데이터 처리 연산 : 데이터베이스와 비슷한 연산 지원 ( filter, amp, reduce, find, match, sort 로 데이터 조작), 순차적으로 병렬 실행

- 파이프라이닝 : 스트림연산은 연산끼리 연결해 커다란 파이프와 같이 구성하고 스트림 자신을 반환 하도록 함. **게으름, 쇼트서킷**과 같은 최적화도 얻을수 있었음’

- 내부 반복 : 컬렉션 같은 경우 반복자를 이용해 명시적으로 내용을 반복하지만 스트림은 내부 반복을 지원한다

```java
import static java.util.stram.Collectors.toList;
List<String> threeHighCaloricDishNames = 
		menu.stram() // <- 메뉴(요리 리스트)에서 스트림을 얻는다
			.filter(dish -> dish.getCalories() > 300 )
			.map(Dish::getName) // <- 요리명 추출
			.limit(3) // <- 선착순 세 개만 선택
			.collect(toList()); // <- 결과를 다른 리스트로 저장
System.out.println(threeHighCaloricDishNames); // <- 결과는 [port, beef, chicken]
```

<br>

데이터 소스 menu(연속된 요소)를  filter, map, limit 와 같은 연산으로 파이프 라인 형성할수 있도록 만듬 collect 연산으로 파이프라인 처리에 결과를 반환(collect 는 스트림이 아닌 List를 반환함)

마지막 collect 호출 되기 전까지는 menu에서 그 무엇도 선택되지도 않으며, 출력결과도 없다!!

→ collect가 호출되기 전까지 메서드 호출은 모두 저장이 되는것이다!

Collect : 스트림을 다른 형석으로 변환한다. (예제 에서는 List로) 변환 방법을 인수로 받아 스트림에 누적된 요소를 특정 결과로 반환하는 기능을 수행한다. (예제의 toList()는 스트림을 리스트로 변환하라 지시하는 인수다)

스트림 라이브러리에서 filter, map, limit 과 같은 기능을 제공하므로 파이프라인을 더 최적화 하는 유연성을 제공한다

<br>

### 스트림과 컬렉션의 차이

ex) DVD같은 경우 어떠한 영화가 저장되어 있기에 **컬렉션**이다, 
인터넷 스트리밍 같은 경우 **스트림**으로 시청하는 부분의 몇 프레임만 미리 내려 받으며 대부분의 값을 처리하지 않은 상태로 미리 내려받은 프레임부터 재생한다 

<br>

데이터를 **언제** 계산하느냐?

**컬렉션**은 현재 자료구조 포함하는 모든 값을 메모리에 저장하므로 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. ( 이러한 연산 수행할 때마다 모든 요소를 메모리에 저장하며 추가요소는 미리 계산해야 한다 )

**스트림**은 요청할 때만 요소를 계산해 고정된 자료구조다. (스트림에 요소 추가나 제거를 할수가 없다) 사용자가 요청하는 값만 스트림에서 추출하는것이 핵심이다. 결과적으로 볼대는 생산자와 소비자 같이 관계가 된다. 또한 게으르게 만들어져 사용자가 데이터 요청할 때만 값을 계산 한다. 

컬렉션은 적극적으로 생산하므로 

소수를 구할때 무한 루프를 돌며 끝없는 소수를 포함하려 해, 결과 값을 알지 못하게 될거다.

ex) 브라우저 인터넷 검색할 때 구글에서 검색하면 모든 결과 나오기 전에 10개, 20개 결과요소를 스트림으로 받아볼 수 있다. (다음을 누르면 요청을 받아 계산해서 브라우저에 표시할거다)

스트림은 단 한번만 탐색할 수 있다. 즉 탐색된 스트림요소는 소비된다. 만약에 I / O 로 받게되면 새로운 스트림을 만들수 없어 반복할 수도 없다

<br>
<br>

### 외부 반복, 내부 반복

컬렉션은 인터페이스 사용을 위해 사용자가 ‘직접 반복’ 해야한다. (for - each)

스트림은 반복을 알아서 처리하며 결과값을 어딘가에 저장하는 ‘내부 반복’ 한다
- 함수에 어떤 작업 수행할짐나 지정하면 모든 것 알아서 해준다

```java
순차(외부적 반복)

List<String> names = new ArrayList<>();
for(Dish dish: menu) { // 메뉴 리스트 명시적으로 **순차 반복**
		names.add(dish.getName()); // <- 이름 추출해 리스트 추가
}

내부
List<String> names = menu.stram().map(Dish::getName) 
// <- map 메서드 getName 메서드로 파라미터화, 요리명 추출
						 .collect(toList());
                        // <- 파이프라인 실행, 반복 필요없음

내부 반복을 함으로서
1. 한가지 일을 하며 다른 일을 하는 **동시처리가 가능하다**
2. 모든관련 자료를 한곳에 모아 처리할수 있다. **(최적화가 가능하다)**

이와 같이 내부반복은 데이터 표현과 하드웨어 활용 병렬성 구현을 자동 선택한다
```

<br>

![https://velog.velcdn.com/images/adam2/post/5ecab89a-4c60-4ba6-bc36-3a58915d8b1b/image.png](https://velog.velcdn.com/images/adam2/post/5ecab89a-4c60-4ba6-bc36-3a58915d8b1b/image.png)

이로서 반복과정을 사용자가(바로 내가?) 신경 쓰지 않아도 된다. 그런데 그러기 위해 사전적으로 filter, map 과 같은 반복 숨겨주는 연산리스트가 미리 정의되어 있어야 한다

<br>

### 스트림 연산

중간 연산과 최종 연산으로 나뉘게 된다.

중간 연산 : 단말 연산을 스트림 파이프라인에 실행하기 전까지 아무 연산도 수행하지 않는다. (게으르다! 모든 연산을 합쳐 최종 연산으로 한번에 처리한다)

```java
중간 연산에서 출력코드 출력은 좋지 않지만 (공부하기에는 참좋은거 같다)

List<String> names = 
		menu.stram()
		.filter(dish -> {
						System.out.println("filtering:" + dishgetName());
						return dish.getCalories() > 300;
}) // 필터링한 요리명 출력
		.map(dish -> {
					System.out.println("mapping:" + dish.getName());
					return dish.getName();
}) // 추출한 요리명 출력
		.limit(3)
		.collect(toList());
System.out.println(names);

여기서 limit 과 관련된 **쇼트서킷**과 filter, map 을 한과정으로 병합한 **루프 퓨전**이있다. (알고만 있자)
```

<br>

최종 연산 : List, Integer, void 와 같은 스트림 이외 결과가 반환된다.

스트림을 요악하잠녀

질의 수행하는 (컬렉션과 같은) 데이터 소스

스트림 파이프라인 구성하는 중간 연산 연결

스트림 파이프라인 실행하고 결과 만드는 최종 연산이 있다

<br>

중간 연산

| 연산 | 형식 | 반환 형식 | 연산의 인수 | 함수 디스트립터 |
| --- | --- | --- | --- | --- |
| filter | 중간 연산 | Stram<T> | Predicate<T> | T → boolean |
| map | 중간 연산 | Stram<R> | Funciton<T, R> | T → R |
| limit | 중간 연산 | Stram<T> |  |  |
| sorted | 중간 연산 | Stram<T> | Comparator<T> | (T, T) → int |
| distinct | 중간 연산 | Stram<T> |  |  |

<br>

최종 연산

| 연산 | 형식 | 반환 형식 | 목적 |
| --- | --- | --- | --- |
| forEach | 최종 연산 | void | 스트림의 각 요소를 소비하며 람다 적용 |
| count | 최종 연산 | long(generic) | 스트림의 요소 개수 반환 |
| collect | 최종 연산 |  | 스트림을 리듀스해 리스트, 맵, 정수 형식의 컬렉션 만듬 |

<br>
<br>

정리

스트림은 추출된 연속 요소의 데이터 처리 연산을 한다

내부 반복을 지원하며 filter, map, sorted 등의 연산으로 반복을 추상화 한다

중간 연산과 최종 연산을 나눠, 중간 연산은 파이프라인을 구성 하지만 어떤 결가도 생성하지 않는다

forEach, count 와 같이 파이프라인은 처리, 스트림 아닌 결과를 반환하는 최종 연산이 있다

스트림은 나같이. 게으르게 계산된다